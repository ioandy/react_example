<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="Generator" content="EditPlus®">
    <meta name="Author" content="">
    <meta name="Keywords" content="">
    <meta name="Description" content="">
    <title>Document</title>
</head>
<body>
    <h2>状态改变 -> 构建新的 DOM 元素更新页面</h2>
    <h5>一旦状态发生改变，就重新调用 render 方法，构建一个新的 DOM 元素</h5>

    <div class='wrapper'> </div>

    <script type="text/javascript">
        const createDOMFromString = (domString) => {
            const div = document.createElement('div')
            div.innerHTML = domString
            return div
        }

        class LikeButton {
            constructor() {
                this.state = {isLiked: true}
            }

            setState(state) {
                // 改变状态的同时，需要更新Dom
                const oldEl = this.el
                this.state = state;
                this.el = this.render();
                if (this.onStateChange)
                    this.onStateChange(oldEl, this.el)
            }

            changeLikeText() {
                this.setState({
                    isLiked: !this.state.isLiked
                });
            }

            render() {
                this.el = createDOMFromString(
                    `
                        <button id='like-btn'>
                          <span class='like-text'>${this.state.isLiked ? '取消' : '点赞'}</span>
                          <span>👍</span>
                        </button>
                    `
                );
                this.el.addEventListener('click', this.changeLikeText.bind(this), false);
                return this.el;
            }
        }

        const wrapper = document.querySelector('.wrapper')
        const button = new LikeButton();
        wrapper.appendChild(button.render()); // 第一次插入 DOM 元素
        button.onStateChange = (oldEl, newEl) => {
            wrapper.insertBefore(newEl, oldEl) // 插入新的元素
            wrapper.removeChild(oldEl) // 删除旧的元素
        }

        /*
        这里每次 setState 都会调用 onStateChange 方法，而这个方法是实例化以后时候被设置的，所以你可以自定义 onStateChange 的行为。
        这里做的事是，每当 setState 中构造完新的 DOM 元素以后，就会通过 onStateChange 告知外部插入新的 DOM 元素，然后删除旧的元素，页面就更新了。
        这里已经做到了进一步的优化了：现在不需要再手动更新页面了。
        非一般的暴力，因为每次 setState 都重新构造、新增、删除 DOM 元素，会导致浏览器进行大量的重排，严重影响性能。
        不过没有关系，这种暴力行为可以被一种叫 Virtual-DOM 的策略规避掉。
         */

    </script>
</body>
</html>